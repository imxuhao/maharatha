<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-selection-CheckboxModel'>/**
</span> * A selection model that renders a column of checkboxes that can be toggled to
 * select or deselect rows. The default mode for this selection model is MULTI.
 *
 *       @example
 *       var store = Ext.create(&#39;Ext.data.Store&#39;, {
 *           fields: [&#39;name&#39;, &#39;email&#39;, &#39;phone&#39;],
 *           data: [{
 *               name: &#39;Lisa&#39;,
 *               email: &#39;lisa@simpsons.com&#39;,
 *               phone: &#39;555-111-1224&#39;
 *           }, {
 *               name: &#39;Bart&#39;,
 *               email: &#39;bart@simpsons.com&#39;,
 *               phone: &#39;555-222-1234&#39;
 *           }, {
 *               name: &#39;Homer&#39;,
 *               email: &#39;homer@simpsons.com&#39;,
 *               phone: &#39;555-222-1244&#39;
 *           }, {
 *               name: &#39;Marge&#39;,
 *               email: &#39;marge@simpsons.com&#39;,
 *               phone: &#39;555-222-1254&#39;
 *           }]
 *       });
 *
 *       Ext.create(&#39;Ext.grid.Panel&#39;, {
 *           title: &#39;Simpsons&#39;,
 *           store: store,
 *           columns: [{
 *               text: &#39;Name&#39;,
 *               dataIndex: &#39;name&#39;
 *           }, {
 *               text: &#39;Email&#39;,
 *               dataIndex: &#39;email&#39;,
 *               flex: 1
 *           }, {
 *               text: &#39;Phone&#39;,
 *               dataIndex: &#39;phone&#39;
 *           }],
 *           height: 200,
 *           width: 400,
 *           renderTo: Ext.getBody(),
 *           selModel: {
 *               selType: &#39;checkboxmodel&#39;
 *           }
 *       });
 *
 * The selection model will inject a header for the checkboxes in the first view
 * and according to the {@link #injectCheckbox} configuration.
 */
Ext.define(&#39;Ext.selection.CheckboxModel&#39;, {
    alias: &#39;selection.checkboxmodel&#39;,
    extend: &#39;Ext.selection.RowModel&#39;,

<span id='Ext-selection-CheckboxModel-cfg-mode'>    /**
</span>     * @cfg {&quot;SINGLE&quot;/&quot;SIMPLE&quot;/&quot;MULTI&quot;} mode
     * Modes of selection.
     * Valid values are `&quot;SINGLE&quot;`, `&quot;SIMPLE&quot;`, and `&quot;MULTI&quot;`.
     */
    mode: &#39;MULTI&#39;,

<span id='Ext-selection-CheckboxModel-cfg-injectCheckbox'>    /**
</span>     * @cfg {Number/String} [injectCheckbox=0]
     * The index at which to insert the checkbox column.
     * Supported values are a numeric index, and the strings &#39;first&#39; and &#39;last&#39;.
     */
    injectCheckbox: 0,

<span id='Ext-selection-CheckboxModel-cfg-checkOnly'>    /**
</span>     * @cfg {Boolean} checkOnly
     * True if rows can only be selected by clicking on the checkbox column, not by clicking
     * on the row itself. Note that this only refers to selection via the UI, programmatic
     * selection will still occur regardless.
     */
    checkOnly: false,
    
<span id='Ext-selection-CheckboxModel-cfg-showHeaderCheckbox'>    /**
</span>     * @cfg {Boolean} showHeaderCheckbox
     * Configure as `false` to not display the header checkbox at the top of the column.
     * When the store is a {@link Ext.data.BufferedStore BufferedStore}, this configuration will
     * not be available because the buffered data set does not always contain all data.
     */
    showHeaderCheckbox: undefined,

<span id='Ext-selection-CheckboxModel-cfg-checkSelector'>    /**
</span>     * @cfg {String} [checkSelector=&quot;x-grid-row-checker&quot;]
     * The selector for determining whether the checkbox element is clicked. This may be changed to
     * allow for a wider area to be clicked, for example, the whole cell for the selector.
     */
    checkSelector: &#39;.&#39; + Ext.baseCSSPrefix + &#39;grid-row-checker&#39;,

<span id='Ext-selection-CheckboxModel-cfg-allowDeselect'>    allowDeselect: true,
</span>
<span id='Ext-selection-CheckboxModel-property-headerWidth'>    headerWidth: 24,
</span>
<span id='Ext-selection-CheckboxModel-property-checkerOnCls'>    // private
</span>    checkerOnCls: Ext.baseCSSPrefix + &#39;grid-hd-checker-on&#39;,

<span id='Ext-selection-CheckboxModel-property-tdCls'>    tdCls: Ext.baseCSSPrefix + &#39;grid-cell-special &#39; + Ext.baseCSSPrefix + &#39;grid-cell-row-checker&#39;,
</span>
<span id='Ext-selection-CheckboxModel-method-constructor'>    constructor: function() {
</span>        var me = this;
        me.callParent(arguments);

        // If mode is single and showHeaderCheck isn&#39;t explicity set to
        // true, hide it.
        if (me.mode === &#39;SINGLE&#39;) {
            //&lt;debug&gt;
            if (me.showHeaderCheckbox) {
                Ext.Error.raise(&#39;The header checkbox is not supported for SINGLE mode selection models.&#39;);
            }
            //&lt;/debug&gt;
            me.showHeaderCheckbox = false;
        }
    },

<span id='Ext-selection-CheckboxModel-method-beforeViewRender'>    beforeViewRender: function(view) {
</span>        var me = this,
            owner,
            ownerLockable = view.grid.ownerLockable;

        me.callParent(arguments);

        // Preserve behaviour of false, but not clear why that would ever be done.
        if (me.injectCheckbox !== false) {

            // The check column gravitates to the locked side unless
            // the locked side is emptied, in which case it migrates to the normal side.
            if (ownerLockable &amp;&amp; !me.lockListeners) {
                me.lockListeners = ownerLockable.mon(ownerLockable, {
                    lockcolumn: me.onColumnLock,
                    unlockcolumn: me.onColumnUnlock,
                    scope: me,
                    destroyable: true
                });
            }

            // If the controlling grid is NOT lockable, there&#39;s only one chance to add the column, so add it.
            // If the view is the locked one and there are locked headers, add the column.
            // If the view is the normal one and we have not already added the column, add it.
            if (!ownerLockable || (view.isLockedView &amp;&amp; me.hasLockedHeader()) || (view.isNormalView &amp;&amp; !me.column)) {
                me.addCheckbox(view, true);
                owner = view.ownerCt;
                // Listen to the outermost reconfigure event
                if (view.headerCt.lockedCt) {
                    owner = owner.ownerCt;
                }

                // Listen for reconfigure of outermost grid panel.
                me.mon(view.ownerGrid, {
                    beforereconfigure: me.onBeforeReconfigure,
                    reconfigure: me.onReconfigure,
                    scope: me
                });
            }
        }
    },

<span id='Ext-selection-CheckboxModel-method-onColumnUnlock'>    onColumnUnlock: function(lockable, column) {
</span>        var me = this,
            checkbox = me.injectCheckbox,
            lockedColumns = lockable.lockedGrid.visibleColumnManager.getColumns();
        
        // User has unlocked all columns and left only the expander column in the locked side.
        if (lockedColumns.length === 1 &amp;&amp; lockedColumns[0] === me.column) {
            if (checkbox === &#39;first&#39;) {
                checkbox = 0;
            } else if (checkbox === &#39;last&#39;) {
                checkbox = lockable.normalGrid.visibleColumnManager.getColumns().length;
            }
            lockable.unlock(me.column, checkbox);
        }
    },

<span id='Ext-selection-CheckboxModel-method-onColumnLock'>    onColumnLock: function(lockable, column) {
</span>        var me = this,
            checkbox = me.injectCheckbox,
            lockedColumns = lockable.lockedGrid.visibleColumnManager.getColumns();

        // User has begun filling the empty locked side - migrate to the locked side..
        if (lockedColumns.length === 1) {
            if (checkbox === &#39;first&#39;) {
                checkbox = 0;
            } else if (checkbox === &#39;last&#39;) {
                checkbox = lockable.lockedGrid.visibleColumnManager.getColumns().length;
            }
            lockable.lock(me.column, checkbox);
        }
    },

<span id='Ext-selection-CheckboxModel-method-bindComponent'>    bindComponent: function(view) {
</span>        this.sortable = false;
        this.callParent(arguments);
    },

<span id='Ext-selection-CheckboxModel-method-hasLockedHeader'>    hasLockedHeader: function(){
</span>        var columns = this.view.ownerGrid.getVisibleColumnManager().getColumns(),
            len = columns.length, i;

        for (i = 0; i &lt; len; i++) {
            if (columns[i].locked) {
                return true;
            }
        }
        return false;
    },

<span id='Ext-selection-CheckboxModel-method-addCheckbox'>    /**
</span>     * Add the header checkbox to the header row
     * @private
     */
    addCheckbox: function(view){
        var me = this,
            checkbox = me.injectCheckbox,
            headerCt = view.headerCt;

        // Preserve behaviour of false, but not clear why that would ever be done.
        if (checkbox !== false) {
            if (checkbox === &#39;first&#39;) {
                checkbox = 0;
            } else if (checkbox === &#39;last&#39;) {
                checkbox = headerCt.getColumnCount();
            }
            Ext.suspendLayouts();
            if (view.getStore().isBufferedStore) {
                me.showHeaderCheckbox = false;
            }
            me.column = headerCt.add(checkbox, me.column || me.getHeaderConfig());
            Ext.resumeLayouts();
        }
    },

<span id='Ext-selection-CheckboxModel-method-onBeforeReconfigure'>    /**
</span>     * Handles the grid&#39;s beforereconfigure event. Removes the checkbox header if the columns are being reconfigured.
     * @private
     */
    onBeforeReconfigure: function(grid, store, columns, oldStore, oldColumns) {
        // Save out check column from destruction.
        // addCheckbox will reuse it instead of creation a new one.
        if (columns) {
            this.column.ownerCt.remove(this.column, false)
        }
    },

<span id='Ext-selection-CheckboxModel-method-onReconfigure'>    /**
</span>     * Handles the grid&#39;s reconfigure event. Adds the checkbox header if the columns have been reconfigured.
     * @private
     * @param {Ext.panel.Table} grid
     * @param {Ext.data.Store} store
     * @param {Object[]} columns
     */
    onReconfigure: function(grid, store, columns) {
        var me = this;

        if (columns) {
            // If it&#39;s a lockable assembly, add the column to the correct side
            if (grid.lockable) {
                if (grid.lockedGrid.isVisible()) {
                    grid.lock(me.column, 0);
                } else {
                    grid.unlock(me.column, 0);
                }
            } else {
                me.addCheckbox(me.view);
            }
        }
    },

<span id='Ext-selection-CheckboxModel-method-toggleUiHeader'>    /**
</span>     * Toggle the ui header between checked and unchecked state.
     * @param {Boolean} isChecked
     * @private
     */
    toggleUiHeader: function(isChecked) {
        var view     = this.views[0],
            headerCt = view.headerCt,
            checkHd  = headerCt.child(&#39;gridcolumn[isCheckerHd]&#39;),
            cls = this.checkerOnCls;

        if (checkHd) {
            if (isChecked) {
                checkHd.addCls(cls);
            } else {
                checkHd.removeCls(cls);
            }
        }
    },

<span id='Ext-selection-CheckboxModel-method-onHeaderClick'>    /**
</span>     * Toggle between selecting all and deselecting all when clicking on
     * a checkbox header.
     */
    onHeaderClick: function(headerCt, header, e) {
        var me = this,
            store = me.store,
            isChecked, records, i, len,
            selections, selection;

        if (me.showHeaderCheckbox !== false &amp;&amp; header === me.column &amp;&amp; me.mode !== &#39;SINGLE&#39;) {
            e.stopEvent();
            isChecked = header.el.hasCls(Ext.baseCSSPrefix + &#39;grid-hd-checker-on&#39;);

            // selectAll will only select the contents of the store, whereas deselectAll
            // will remove all the current selections. In this case we only want to
            // deselect whatever is available in the view.
            if (isChecked) {
                records = [];
                selections = this.getSelection();
                for (i = 0, len = selections.length; i &lt; len; ++i) {
                    selection = selections[i];
                    if (store.indexOf(selection) &gt; -1) {
                        records.push(selection);
                    }
                }
                if (records.length &gt; 0) {
                    me.deselect(records);
                }
            } else {
                me.selectAll();
            }
        }
    },

<span id='Ext-selection-CheckboxModel-method-getHeaderConfig'>    /**
</span>     * Retrieve a configuration to be used in a HeaderContainer.
     * This should be used when injectCheckbox is set to false.
     */
    getHeaderConfig: function() {
        var me = this,
            showCheck = me.showHeaderCheckbox !== false;

        return {
            xtype: &#39;gridcolumn&#39;,
            ignoreExport: true,
            isCheckerHd: showCheck,
            text : &#39;&amp;#160;&#39;,
            clickTargetName: &#39;el&#39;,
            width: me.headerWidth,
            sortable: false,
            draggable: false,
            resizable: false,
            hideable: false,
            menuDisabled: true,
            dataIndex: &#39;&#39;,
            tdCls: me.tdCls,
            cls: showCheck ? Ext.baseCSSPrefix + &#39;column-header-checkbox &#39; : &#39;&#39;,
            defaultRenderer: me.renderer.bind(me),
            editRenderer: me.editRenderer || me.renderEmpty,
            locked: me.hasLockedHeader(),
            processEvent: me.processColumnEvent
        };
    },

<span id='Ext-selection-CheckboxModel-method-processColumnEvent'>    /**
</span>     * @private
     * Process and refire events routed from the Ext.panel.Table&#39;s processEvent method.
     * Also fires any configured click handlers. By default, cancels the mousedown event to prevent selection.
     * Returns the event handler&#39;s status to allow canceling of GridView&#39;s bubbling process.
     */
    processColumnEvent : function(type, view, cell, recordIndex, cellIndex, e, record, row) {
        var navModel = view.getNavigationModel();

        // Fire a navigate event upon SPACE in actionable mode.
        // SPACE events are ignored by the NavModel in actionable mode.
        if (e.type === &#39;keydown&#39; &amp;&amp; view.actionableMode &amp;&amp; e.getKey() === e.SPACE) {
            navModel.fireEvent(&#39;navigate&#39;, {
                view: view,
                navigationModel: navModel,
                keyEvent: e,
                position: e.position,
                recordIndex: recordIndex,
                record: record,
                item: e.item,
                cell: e.position.cellElement,
                columnIndex: e.position.colIdx,
                column: e.position.column
            });
        }
    },

<span id='Ext-selection-CheckboxModel-method-renderEmpty'>    renderEmpty: function() {
</span>        return &#39;&amp;#160;&#39;;
    },

<span id='Ext-selection-CheckboxModel-method-refresh'>    // After refresh, ensure that the header checkbox state matches
</span>    refresh: function() {
        this.callParent(arguments);
        this.updateHeaderState();
    },

<span id='Ext-selection-CheckboxModel-method-renderer'>    /**
</span>     * Generates the HTML to be rendered in the injected checkbox column for each row.
     * Creates the standard checkbox markup by default; can be overridden to provide custom rendering.
     * See {@link Ext.grid.column.Column#renderer} for description of allowed parameters.
     */
    renderer: function(value, metaData, record, rowIndex, colIndex, store, view) {
        return &#39;&lt;div class=&quot;&#39; + Ext.baseCSSPrefix + &#39;grid-row-checker&quot; role=&quot;button&quot; tabIndex=&quot;-1&quot;&gt;&amp;#160;&lt;/div&gt;&#39;;
    },
   
<span id='Ext-selection-CheckboxModel-method-selectByPosition'>    selectByPosition: function (position, keepExisting) {
</span>        if (!position.isCellContext) {
            position = new Ext.grid.CellContext(this.view).setPosition(position.row, position.column);
        }

        // Do not select if checkOnly, and the requested position is not the check column
        if (!this.checkOnly || position.column === this.column) {
            this.callParent([position, keepExisting]);
        }
    },

<span id='Ext-selection-CheckboxModel-method-onSelectChange'>    /**
</span>     * Synchronize header checker value as selection changes.
     * @private
     */
    onSelectChange: function() {
        this.callParent(arguments);
        if (!this.suspendChange) {
            this.updateHeaderState();
        }
    },

<span id='Ext-selection-CheckboxModel-method-onStoreLoad'>    /**
</span>     * @private
     */
    onStoreLoad: function() {
        this.callParent(arguments);
        this.updateHeaderState();
    },

<span id='Ext-selection-CheckboxModel-method-onStoreAdd'>    onStoreAdd: function() {
</span>        this.callParent(arguments);
        this.updateHeaderState();
    },

<span id='Ext-selection-CheckboxModel-method-onStoreRemove'>    onStoreRemove: function() {
</span>        this.callParent(arguments);
        this.updateHeaderState();
    },
    
<span id='Ext-selection-CheckboxModel-method-onStoreRefresh'>    onStoreRefresh: function(){
</span>        this.callParent(arguments);    
        this.updateHeaderState();
    },
    
<span id='Ext-selection-CheckboxModel-method-maybeFireSelectionChange'>    maybeFireSelectionChange: function(fireEvent) {
</span>        if (fireEvent &amp;&amp; !this.suspendChange) {
            this.updateHeaderState();
        }
        this.callParent(arguments);
    },
    
<span id='Ext-selection-CheckboxModel-method-resumeChanges'>    resumeChanges: function(){
</span>        this.callParent();
        if (!this.suspendChange) {
            this.updateHeaderState();
        }
    },

<span id='Ext-selection-CheckboxModel-method-updateHeaderState'>    /**
</span>     * @private
     */
    updateHeaderState: function() {
        // check to see if all records are selected
        var me = this,
            store = me.store,
            storeCount = store.getCount(),
            views = me.views,
            hdSelectStatus = false,
            selectedCount = 0,
            selected, len, i;
            
        if (!store.isBufferedStore &amp;&amp; storeCount &gt; 0) {
            selected = me.selected;
            hdSelectStatus = true;
            for (i = 0, len = selected.getCount(); i &lt; len; ++i) {
                if (store.indexOfId(selected.getAt(i).id) &gt; -1) {
                    ++selectedCount;
                }
            }
            hdSelectStatus = storeCount === selectedCount;
        }
            
        if (views &amp;&amp; views.length) {
            me.toggleUiHeader(hdSelectStatus);
        }
    },

<span id='Ext-selection-CheckboxModel-method-vetoSelection'>    vetoSelection: function(e) {
</span>        var me = this,
            column = me.column,
            veto, isClick, isSpace;

        if (me.checkOnly) {
            isClick = e.type === &#39;click&#39; &amp;&amp; e.getTarget(me.checkSelector);
            isSpace = e.getKey() === e.SPACE &amp;&amp; e.position.column === column;
            veto = !(isClick || isSpace);
        }
        return veto || me.callParent([e]);
    },

<span id='Ext-selection-CheckboxModel-method-destroy'>    destroy: function() {
</span>        this.column = null;
        this.callParent();
    },

<span id='Ext-selection-CheckboxModel-property-privates'>    privates: {
</span>        onBeforeNavigate: function(metaEvent) {
            var e = metaEvent.keyEvent;
            if (this.selectionMode !== &#39;SINGLE&#39;) {
                metaEvent.ctrlKey = metaEvent.ctrlKey || e.ctrlKey || (e.type === &#39;click&#39; &amp;&amp; !e.shiftKey) || e.getKey() === e.SPACE;
            }
        },

        selectWithEventMulti: function(record, e, isSelected) {
            var me = this;

            if (!e.shiftKey &amp;&amp; !e.ctrlKey &amp;&amp; e.getTarget(me.checkSelector)) {
                if (isSelected) {
                    me.doDeselect(record);
                } else {
                    me.doSelect(record, true);
                }
            } else {
                me.callParent([record, e, isSelected]);
            }
        }
    }
});
</pre>
</body>
</html>
