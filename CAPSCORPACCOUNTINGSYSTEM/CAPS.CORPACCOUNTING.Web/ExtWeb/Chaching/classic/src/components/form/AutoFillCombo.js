Ext.define('Chaching.components.form.AutoFillCombo', {
    //extend: 'Ext.form.field.Picker',
    extend: 'Ext.form.field.ComboBox',
    xtype: 'autofillcombo',
    requires: ['Ext.grid.Panel'],

    modulePermissions: undefined,
    nameOfEntity : null,
    entityType: null,
    entityPermission: null,
    entityGridController : null,
    autoSelect: false,
    selectOnFocus : true,
    enableKeyEvents: true,
    typeAhead: false,
    editable: true,
    emptyText: 'Type to search',
    // We're forcing the query to run every time by setting minChars to 0
    // (default is 4)
    minChars: 2,
    queryParam: 'query',
    queryMode: 'remote',
    forceSelection:true,
    listConfig: {
        minWidth: 300
    },
    userDefinedColumns : null,
    onBindStore: function (store, initial) {
        var me = this,
            picker = me.picker,
            extraKeySpec, valueCollectionConfig;
        // We're being bound, not unbound...
        if (store) {
            // If store was created from a 2 dimensional array with generated field names 'field1' and 'field2'
            if (store.autoCreated) {
                me.queryMode = 'local';
                me.valueField = me.displayField = 'field1';
                if (!store.expanded) {
                    me.displayField = 'field2';
                }
                // displayTpl config will need regenerating with the autogenerated displayField name 'field1'
                if (me.getDisplayTpl().auto) {
                    me.setDisplayTpl(null);
                }
            }
            if (!Ext.isDefined(me.valueField)) {
                me.valueField = me.displayField;
            }
            // Add a byValue index to the store so that we can efficiently look up records by the value field
            // when setValue passes string value(s).
            // The two indices (Ext.util.CollectionKeys) are configured unique: false, so that if duplicate keys
            // are found, they are all returned by the get call.
            // This is so that findByText and findByValue are able to return the *FIRST* matching value. By default,
            // if unique is true, CollectionKey keeps the *last* matching value.
            extraKeySpec = {
                byValue: {
                    rootProperty: 'data',
                    unique: false
                }
            };
            extraKeySpec.byValue.property = me.valueField;
            store.setExtraKeys(extraKeySpec);
            if (me.displayField === me.valueField) {
                store.byText = store.byValue;
            } else {
                extraKeySpec.byText = {
                    rootProperty: 'data',
                    unique: false
                };
                extraKeySpec.byText.property = me.displayField;
                store.setExtraKeys(extraKeySpec);
            }
            // We hold a collection of the values which have been selected, keyed by this field's valueField.
            // This collection also functions as the selected items collection for the BoundList's selection model
            valueCollectionConfig = {
                rootProperty: 'data',
                extraKeys: {
                    byInternalId: {
                        property: 'internalId'
                    },
                    byValue: {
                        property: me.valueField,
                        rootProperty: 'data'
                    }
                },
                // Whenever this collection is changed by anyone, whether by this field adding to it,
                // or the BoundList operating, we must refresh our value.
                listeners: {
                    beginupdate: me.onValueCollectionBeginUpdate,
                    endupdate: me.onValueCollectionEndUpdate,
                    scope: me
                }
            };
            // This becomes our collection of selected records for the Field.
            me.valueCollection = new Ext.util.Collection(valueCollectionConfig);
            // This is the selection model we configure into the dropdown BoundList.
            // We use the selected Collection as our value collection and the basis
            // for rendering the tag list.
            me.pickerSelectionModel = new Ext.selection.RowModel({
                mode: me.multiSelect ? 'SIMPLE' : 'SINGLE',
                // There are situations when a row is selected on mousedown but then the mouse is dragged to another row
                // and released.  In these situations, the event target for the click event won't be the row where the mouse
                // was released but the boundview.  The view will then determine that it should fire a container click, and
                // the DataViewModel will then deselect all prior selections. Setting `deselectOnContainerClick` here will
                // prevent the model from deselecting.
                //deselectOnContainerClick: false,
                //enableInitialSelection: false,
                //pruneRemoved: false,
                //selected: me.valueCollection,
                store: store,
                listeners: {
                    scope: me,
                    lastselectedchanged: me.updateBindSelection
                }
            });
            if (!initial) {
                me.resetToDefault();
            }
            if (picker) {
                me.pickerSelectionModel.on({
                    scope: me,
                    beforeselect: me.onBeforeSelect,
                    beforedeselect: me.onBeforeDeselect
                });
                picker.setSelectionModel(me.pickerSelectionModel);
                if (picker.getStore() !== store) {
                    picker.bindStore(store);
                }
            }
        }
    },
    initComponent: function () {
        var me = this;
        if (me.entityGridController == null) {
            Ext.raise('entityGridController config is required for add/update/delete of an entity for AutoFillCombo(' + me.nameOfEntity + ')');
        }
        if (me.nameOfEntity == null) {
            Ext.raise('nameOfEntity config is required to open edit/create page in popup window for that entity.');
        }
        if (me.entityType == null ) {
            Ext.raise('entityType config is required to open edit/create page  in popup window for that entity.');
        }
        if (me.entityPermission == null&&!me.modulePermissions) {
            Ext.raise('entityPermission config is required to show or hide action buttons in grid(autocompletecombo).');
        }
        if (me.selectOnFocus && !me.editable) {
            Ext.raise('If selectOnFocus is enabled the combo must be editable: true -- please change one of those settings.');
        }
        //add create icon based upon permission
        if (!me.modulePermissions) {
            me.modulePermissions = {
                read: abp.auth.isGranted('Pages.' + me.entityPermission),
                create: abp.auth.isGranted('Pages.' + me.entityPermission + '.Create'),
                edit: abp.auth.isGranted('Pages.' + me.entityPermission + '.Edit'),
                destroy: abp.auth.isGranted('Pages.' + me.entityPermission + '.Delete')
            };
        }
        me.callParent(arguments);
        //key events
        me.on('keyup', me.baseKeyUp, this);
        me.on('specialkey', me.baseSpecialkey, this);
    },

    setRecordOnLoad : function(field, newVal, oldVal) {
    },
    
    baseKeyUp: function (obj, e, eOpts) {
        obj.handleKeyUp(obj, e, eOpts);
    },

    baseSpecialkey: function (obj, e, eOpts) {
       
        //Merged the code of #5135
        var me = this;
        if (e.getKey() === e.ENTER || e.getKey() === e.TAB || (e.shiftKey && e.getKey() === e.TAB)) {
            me.handleKeyDown(obj, e, eOpts);
        } else if (e.getKey() === e.DOWN) {
            // select the first record on down arrow.
            me.handleKeyUp(obj, e, eOpts);
            if (me.picker && me.isExpanded) {
                e.stopEvent();
                var selectionModel = me.picker.getSelectionModel();
                selectionModel.deselectAll();
                selectionModel.select(0);
                me.picker.getView().focus();
                me.picker.getView().focusRow(0);
            }
        }
    },
    handleKeyUp: function (obj, key, eOpts) {
      
        var me = this;
        if (key && key.isNavKeyPress()) {
            if (key.getKey() === key.DOWN) {
                if (!me.isExpanded) return false;
                var store = me.getStore();
                var count = store.getCount();
                if (count <= 0) return false;
                me.getPicker().toFront();
                return true;
            }

            // Expanding only in case of NavigationKey is pressed. 
            // Disabling the expand in case of SHIFT + TAB, as it was causing other issues.
            if (!me.isExpanded) {
                me.expand();
            }

            if (me.isExpanded) me.getPicker().toFront();
        }

        if (key && (key.getKey() === key.ESC || key.getKey() === key.ENTER || key.getKey() === key.TAB)) {
            obj.collapse();
            return true;
        }

        return true;
    },


    handleKeyDown: function (obj, key, eOpts) {
        var me = this;
        if (key && (key.getKey() === key.ENTER || key.getKey() === key.TAB)) {
            var picker = me.getPicker();
            if (picker) {
                picker.suspendEvents(true);
                this.handlePickerEvent('btnSelect');
                picker.resumeEvents();
            }
            return false;
        }
        return true;
    },
    getValue: function () {
        var me = this;
        return me.hiddenValue;
    },

    getTextValue: function () {
        var me = this;
        return me.value;
    },
    onSelect: function (record) {
        debugger;
        if (!this.preventSelectOnClick) {
            var me = this;
            var idVal = record.data[me.valueField];
            var nameVal = record.data[me.displayField];
            me.setValue(idVal);
            me.fireEvent('change', me, idVal, record);
            me.collapse();
            me.fireEvent('select', me, record);
        }
    },
    handlePickerEvent: function (event, rec) {
        var me = this,
            picker = me.getPicker(),
            view = picker.getView(),
            model = view.getSelectionModel(),
            record = model.getLastSelected(),
            parentWindow = me.up('window');
        // Added for #3103 - Default Values on PR Import Form
        if (!record && rec) record = rec;

        if (!record && view.store.getCount() == 1) {
            // get it from view 
            record = view.store.getAt(0);
        }

        switch (event) {
            // Added two diffirent events to resolve issue of key events & mouse events.
            case 'btnSelectClicked':
                if (record) {
                    me.onSelect(record);
                    model.deselectAll();
                    model.lastSelected = undefined;
                    // clear last filter used and last query
                    me.lastQuery = '';
                    me.getStore().clearFilter();
                }
                break;
            case 'btnSelect':
                if (me.getRawValue()) {
                    if (record) {
                        me.onSelect(record);
                    } else {
                        if (me.value && me.hiddenValue) {
                            var r = undefined;
                            r = me.getStore().findRecord(me.displayField, me.rawValue);
                            if (r) {
                                me.hiddenValue = r.get(me.valueField);
                            } else {
                                me.setValue('');
                            }
                        } else {
                            me.setValue('');
                        }
                        me.focus();
                    }
                } else {
                    me.hiddenValue = '';
                    me.setValue('');
                    me.collapse();
                    me.focus();
                }
                // clear last filter used and last query
                model.lastSelected = undefined;
                me.lastQuery = '';
                me.getStore().clearFilter();
                model.deselectAll();
                break;
            case 'btnRefresh':
                me.getPicker().getSelectionModel().deselectAll();
               
                me.store.load({ params: me.store.params });
                break;
        }
    },
    /**
     * Creates and returns the grid panel to be used as this field's picker.
     */
    createPicker: function () {
        var me = this,
            dockedItems = [{
                 anchor: '100%',
                 dock: 'bottom',
                 ui: 'plainBottom',
                 frame: false,
                 xtype: 'toolbar',
                 items: ['->', {
                     xtype: 'button',
                     text: 'Add',
                     tooltip: 'Add' + " " + me.nameOfEntity,
                     iconAlign: 'left',
                     scale: 'small',
                     iconCls: 'fa fa-plus-square',
                     ui: 'actionButton',
                     handler: function (btn) {
                         var entityType = me.entityType;
                         me.createWindow(entityType, 'create', null);
                     }
                 }]
             }],
            columnList = me.createGridColumns();
	        opts = Ext.apply({
	            shrinkWrapDock: 2,
	            manageHeight: true,
	            store: me.store,
	            displayField: me.displayField,
	            columns: columnList,
	            columnLines: false,
	            rowLines: false,
	            forceFit: true,
	            layout: 'fit',
	            recordToSetInComboBox: null,
	            floating: true,
	            dockedItems: me.modulePermissions.create ? dockedItems : null,
	            multiSelect: false,
	            cls: 'chaching-transactiongrid',
	            controller: me.entityGridController,
	            selModel: {
	                selType: 'rowmodel' // rowmodel is the default selection model
	            },
	            viewConfig: {
	                stripeRows: true,
                    emptyText : 'No Records Found'
	            }
                //,
	            //listeners: {
	            //    scope: me,
	            //    itemclick: me.onItemClick,
	            //}
	        }, me.listConfig);
	       
	        var picker = me.picker = Ext.create('Ext.grid.Panel', opts);
        me.pickerSelectionModel = picker.getSelectionModel();
        picker.on({
           // select: me.onPickerSelect,
            blur: me.onPickerBlur,
            celldblclick: me.onPickerCellDblClick,
            //selectionchange: me.onPickerSelectionChange,
            refresh: me.onListRefresh,
            scope: me
        });


        picker.getView().on('itemkeydown', me.onViewItemKeyDown);

        // hack: pass getNode() to the view
        picker.getNode = function () {
            picker.getView().getNode(arguments);
        };

        //To findout Mac System and Only for Mozilla.
        if (Ext.isGecko && Ext.isMac) {
            me.keyMap = new Ext.util.KeyMap({
                target: me.inputEl,
                key: [40, 38],
                fn: me.baseSpecialkey,
                scope: me
            });
        }
        return picker;
    },

   

    // Picker Events
    onPickerNew: function () {
        this.handlePickerEvent('btnNew');
    },

    onPickerEdit: function () {
        this.handlePickerEvent('btnEdit');
    },

    onPickerDelete: function () {
        this.handlePickerEvent('btnDelete');
    },

    onPickerRefresh: function () {
        this.handlePickerEvent('btnRefresh');
    },

    onPickerSelected: function () {
        this.handlePickerEvent('btnSelectClicked');
    },

    onPickerSelect: function () {
        return false; // do nothing
    },

    onPickerBlur: function () {
        this.handlePickerEvent('btnSelectClicked');
    },

    onPickerCellDblClick: function (field, td, cellIndex, record, tr, rowIndex, e, eOpts) {
        // fire select  
        var me = this;
        if (!me.preventSelectOnDblClick) {
            this.handlePickerEvent('btnSelectClicked');
        }
    },

    onPickerSelectionChange: function () {
        var me = this,
            picker = me.getPicker();

        if (!me.disableEditBtnOnSelection)
            picker.down('button[itemId=btnDropDownEdit]').enable();

        if (!me.disableDeleteBtnOnSelection)
            picker.down('button[itemId=btnDropDownDelete]').enable();

        picker.down('button[itemId=btnDropDownSelect]').enable();

        return false;
    },

    onListRefresh: function () {
        this.alignPicker();
        this.syncSelection();
    },
    onViewItemKeyDown: function (view, record, item, index, e) {
      
        if (e.getKey() == e.ENTER || e.getKey() == e.TAB) {
            // fire select 
            var me = this;
            if (typeof (me.handlePickerEvent) === 'function')
                me.handlePickerEvent('btnSelectClicked');
            else {
                me = this.up('autofillcombo');
                me.handlePickerEvent('btnSelectClicked');
            }
        }
    },
    /*setValue: function (v) {
        var me = this;
        if (!me.preventClearOnBlur || v != "") {
            if (me.preventClearOnBlur) {
                if (this.rawValue != v && this.rawValue != "") {
                    v = this.rawValue;
                }
            }
            if (v === undefined) {
                me.value = "";
                me.setRawValue("");
                return "";
            }

            if (v == null || v == 0 || v == "") {
                me.value = "";
                me.setRawValue("");
            }
            if (typeof (v) === "string") {
                v = Ext.util.Format.htmlDecode(v);
            }
           
            //if (me.isEditMode) {
            //    var record = me.store.findRecord(me.valueField, v);
            //    if (record == null) {
            //        record = me.store.findRecord(me.displayField, v);
            //    }
            //}
            me.value = v;
            me.setRawValue(v);
            me.checkChange();
            if (me.inputEl) {
                me.inputEl.removeCls(me.emptyCls);
            }
        }
        return me;
    },*/
    setValue: function (value) {
        var me = this,
            bind, valueBind;

        // Here we check if the setValue is being called by bind getting synced
        // if this is the case while the field has focus. If this is the case, we
        // don't want to change the field value.
        if (me.hasFocus) {
            bind = me.getBind();
            valueBind = bind && bind.value;
            if (valueBind && valueBind.syncing) {
                if ((Ext.isEmpty(value) && Ext.isEmpty(me.value)) || value === me.value) {
                    return me;
                } else if (Ext.isArray(value) && Ext.isArray(me.value) && Ext.Array.equals(value, me.value)) {
                    return me;
                }
            }
        } else {
            // This is the value used to forceSelection in assertValue if 
            // an invalid value is left in the field at completeEdit. Must be cleared so 
            // that the next usage of the field is not affected, but only if we are setting
            // a new value.
            me.lastSelectedRecords = null;
        }
        if (value != null) {
            if (!me.picker)me.picker = me.getPicker();
            me.doSetValue(value);
        }
            // Clearing is a special, simpler case.
        else {
            me.suspendEvent('select');
            me.valueCollection.beginUpdate();
            me.pickerSelectionModel.deselectAll();
            me.valueCollection.endUpdate();
            me.resumeEvent('select');
        }

        return me;
    },
    /**
     * @private
     * Sets or adds a value/values
     */
    doSetValue: function (value /* private for use by addValue */, add) {

        debugger;
        var me = this,
            store = me.getStore(),
            Model = store.getModel(),
            matchedRecords = [],
            valueArray = [],
            autoLoadOnValue = me.autoLoadOnValue,
            isLoaded = store.getCount() > 0 || store.isLoaded(),
            pendingLoad = store.hasPendingLoad(),
            unloaded = autoLoadOnValue && !isLoaded && !pendingLoad,
            forceSelection = me.forceSelection,
            selModel = me.pickerSelectionModel,
            displayIsValue = me.displayField === me.valueField,
            isEmptyStore = store.isEmptyStore,
            lastSelection = me.lastSelection,
            i, len, record, dataObj,
            valueChanged, key;

        //<debug>
        if (add && !me.multiSelect) {
            Ext.raise('Cannot add values to non multiSelect ComboBox');
        }
        //</debug>

        // Called while the Store is loading or we don't have the real store bound yet.
        // Ensure it is processed by the onLoad/bindStore.
        // Even if displayField === valueField, we still MUST kick off a load because even though
        // the value may be correct as the raw value, we must still load the store, and
        // upon load, match the value and select a record sop we can publish the *selection* to
        // a ViewModel.
        if (pendingLoad || unloaded || !isLoaded || isEmptyStore) {

            // If they are setting the value to a record instance, we can
            // just add it to the valueCollection and continue with the setValue.
            // We MUST do this before kicking off the load in case the load is synchronous;
            // this.value must be available to the onLoad handler.
            if (!value.isModel) {
                if (add) {
                    me.value = Ext.Array.from(me.value).concat(value);
                } else {
                    me.value = value;
                }

                me.setHiddenValue(me.value);

                // If we know that the display value is the same as the value, then show it.
                // A store load is still scheduled so that the matching record can be published.
                me.setRawValue(displayIsValue ? value : '');
                // if display is value, let's remove the empty text since the store might not be loaded yet
                if (displayIsValue && !Ext.isEmpty(value) && me.inputEl && me.emptyText) {
                    me.inputEl.removeCls(me.emptyUICls);
                    me.valueContainsPlaceholder = false;
                }
            }

            // Kick off a load. Doesn't matter whether proxy is remote - it needs loading
            // so we can select the correct record for the value.
            //
            // Must do this *after* setting the value above in case the store loads synchronously
            // and fires the load event, and therefore calls onLoad inline.
            //
            // If it is still the default empty store, then the real store must be arriving
            // in a tick through binding. bindStore will call setValueOnData.
            if (unloaded && !isEmptyStore) {
                store.load();
            }

            // If they had set a string value, another setValue call is scheduled in the onLoad handler.
            // If the store is the defauilt empty one, the setValueOnData call will be made in bindStore
            // when the real store arrives.
            if (!value.isModel || isEmptyStore) {
                return me;
            }
        }

        // This method processes multi-values, so ensure value is an array.
        value = add ? Ext.Array.from(me.value).concat(value) : Ext.Array.from(value);

        // Loop through values, matching each from the Store, and collecting matched records
        for (i = 0, len = value.length; i < len; i++) {
            record = value[i];

            // Set value was a key, look up in the store by that key
            if (!record || !record.isModel) {
                record = me.findRecordByValue(key = record);

                // The value might be in a new record created from an unknown value (if !me.forceSelection).
                // Or it could be a picked record which is filtered out of the main store.
                // Or it could be a setValue(record) passed to an empty store with autoLoadOnValue and aded above.
                if (!record) {
                    record = me.valueCollection.find(me.valueField, key);
                }
            }
            // record was not found, this could happen because
            // store is not loaded or they set a value not in the store
            if (!record) {
                // If we are allowing insertion of values not represented in the Store, then push the value and
                // create a new record to push as a display value for use by the displayTpl
                if (!forceSelection) {

                    // We are allowing added values to create their own records.
                    // Only if the value is not empty.
                    if (!record && value[i]) {
                        dataObj = {};
                        dataObj[me.displayField] = value[i];
                        if (me.valueField && me.displayField !== me.valueField) {
                            dataObj[me.valueField] = value[i];
                        }
                        record = new Model(dataObj);
                    }
                }
                    // Else, if valueNotFoundText is defined, display it, otherwise display nothing for this value
                else if (me.valueNotFoundRecord) {
                    record = me.valueNotFoundRecord;
                }
            }
            // record found, select it.
            if (record) {
                matchedRecords.push(record);
                valueArray.push(record.get(me.valueField));
            }
        }

        // If the same set of records are selected, this setValue has been a no-op
        if (lastSelection) {
            len = lastSelection.length;
            if (len === matchedRecords.length) {
                for (i = 0; !valueChanged && i < len; i++) {
                    if (Ext.Array.indexOf(me.lastSelection, matchedRecords[i]) === -1) {
                        valueChanged = true;
                    }
                }
            } else {
                valueChanged = true;
            }
        } else {
            valueChanged = matchedRecords.length;
        }

        if (valueChanged) {
            // beginUpdate which means we only want to notify this.onValueCollectionEndUpdate after it's all changed.
            me.suspendEvent('select');
            me.valueCollection.beginUpdate();
            if (matchedRecords.length) {
                selModel.select(matchedRecords, false);
            } else {
                selModel.deselectAll();
            }
            me.valueCollection.endUpdate();
            me.resumeEvent('select');
        } else {
            me.updateValue();
        }

        if (me.inputEl && me.emptyText) {
            me.inputEl.removeCls(me.emptyCls);
            me.valueContainsPlaceholder = false;
        }
        if (record) {
            me.setRawValue(record.get(me.displayField));
            me.value = record.get(me.valueField);
        }
        me.applyEmptyText();

        return me;
    },
    doQuery: function (queryString, forceAll, rawQuery) {
        var me = this,
            store = me.getStore(),
            filters = store.getFilters(),
            // if we have a queryString and the queryFilter is not filtering the store, we should do a localQuery
            refreshFilters = !!queryString && me.queryFilter && (filters.indexOf(me.queryFilter) < 0),
            // Decide if, and how we are going to query the store
            queryPlan = me.beforeQuery({
                lastQuery: me.lastQuery || '',
                query: queryString || '',
                rawQuery: rawQuery,
                forceAll: forceAll,
                combo: me,
                cancel: false
            });
        // Allow veto.
        if (queryPlan !== false && !queryPlan.cancel) {
            // If they're using the same value as last time (and not being asked to query all), 
            // and the filters don't need to be refreshed, just show the dropdown
            if (me.queryCaching && !refreshFilters && queryPlan.query === me.lastQuery) {
                // The filter changing was done with events suppressed, so
                // refresh the picker DOM while hidden and it will layout on show.
                me.getPicker().getView().refresh();
                me.expand();
                me.afterQuery(queryPlan);
            } else // Otherwise filter or load the store
            {
                me.lastQuery = queryPlan.query;
                if (me.queryMode === 'local') {
                    me.doLocalQuery(queryPlan);
                } else {
                    me.doRemoteQuery(queryPlan);
                }
            }
            return true;
        } else // If the query was vetoed we still need to check the change
            // in case custom validators are used
        {
            me.startCheckChangeTask();
        }
        return false;
    },

    createGridColumns: function () {
        var me = this,
            //store = Ext.create('Chaching.store.' + me.store),
             store = me.store,
           // model = me.store.model.create(),
            fileds = store.model.fields.items,
            count = fileds.length,
            columns = [];

        if (me.userDefinedColumns == null) {
            for (var i = 0; i < count; i++) {
                if (fileds[i].hidden == false) {
                    var column = {
                        text: fileds[i].headerText == null ? fileds[i].name : app.localize(fileds[i].headerText),
                        sortable: false,
                        hideable: false,
                        menuDisabled: true,
                        filterable: true,
                        minWidth: 50,
                        width: fileds[i].width,
                        hidden: fileds[i].hidden,
                        dataIndex: fileds[i].name,
                        flex: fileds[i].width > 0 ? null : fileds[i].flex
                    }
                    columns.push(column);
                }
            }
        } else {
            count = me.userDefinedColumns.length;
            for (var i = 0; i < count; i++) {
                if (userDefinedColumns[i].hidden == false) {
                    var column = {
                        text: userDefinedColumns[i].headerText == null ? userDefinedColumns[i].name : app.localize(userDefinedColumns[i].headerText),
                        sortable: false,
                        hideable: false,
                        menuDisabled: true,
                        filterable: true,
                        minWidth: 50,
                        width: userDefinedColumns[i].width,
                        hidden: userDefinedColumns[i].hidden,
                        dataIndex: userDefinedColumns[i].name,
                        flex: userDefinedColumns[i].width > 0 ? null : userDefinedColumns[i].flex
                    }
                    columns.push(column);
                }
            }
        }
       
      
        var actionColumn = {};
        var actionColumnItems = [];
        var editActionItem = {
            scale: 'small',
            iconCls: 'editCls',
          //  ui: 'actionButton',
            tooltip: app.localize('Edit') + " " +me.nameOfEntity,
            handler : function(grid, rowIndex, colIndex) {
                var entityType = me.entityType;
                var rec = grid.getStore().getAt(rowIndex);
                me.createWindow(entityType, 'edit', rec);
               
            }
        };
        var deleteActionItem = {
            scale: 'small',
            iconCls: 'deleteCls',
           // ui: 'actionButton',
            tooltip: app.localize('Delete') + " " + me.nameOfEntity,
            handler: function (grid, rowIndex, colIndex) {
                var entityType = me.entityType;
                var rec = grid.getStore().getAt(rowIndex);
                me.createWindow(entityType, 'delete', rec);
            }
        };
        if (me.modulePermissions.edit) {
           // actionColumnItems.push(editActionItem);

            var editActionColumn = {
                xtype: 'actioncolumn',
                width: '5%',
                minWidth: 15,
                sortable: false,
                hideable: false,
                menuDisabled: true,
                filterable: true,
                items: [editActionItem]//actionColumnItems
            }
            columns.push(editActionColumn);
        }

        if (me.modulePermissions.destroy) {
            //actionColumnItems.push(deleteActionItem);
            var deleteActionColumn = {
                xtype: 'actioncolumn',
                width: '5%',
                minWidth: 15,
                sortable: false,
                hideable: false,
                menuDisabled: true,
                filterable: true,
                items: [deleteActionItem]//actionColumnItems
            }
            columns.push(deleteActionColumn);
        }

        //if (actionColumnItems.length > 0) {
        //    actionColumn = {
        //        xtype: 'actioncolumn',
        //        width: '8%',
        //        minWidth: 30,
        //        sortable: false,
        //        hideable: false,
        //        menuDisabled: true,
        //        filterable: true,
        //        items: actionColumnItems
        //    }
        //    columns.push(actionColumn);
        //} 
       return columns;
    },
    createWindow: function (xtype, operation, record) {
        var me = this,
            picker = me.picker;
        if (!picker) me.picker = me.getPicker();
        var xtypeOfView = "";
        if (operation === 'create') {
            xtypeOfView = xtype + ".create";
        } else if (operation === 'edit') {
            xtypeOfView = xtype + ".edit";
        }

        if (me.store && me.store.proxy && (me.store.proxy.urlToGetRecordById == "" || me.store.proxy.urlToGetRecordById == undefined)) {
            Ext.raise('urlToGetRecordById config is required in proxy config of ' + me.store.$className + ' to edit record in AutoFillCombo(' + me.nameOfEntity+')');
        }
        var recordByIdUrl = me.store.proxy.urlToGetRecordById;
        if (operation === 'edit') {
            Ext.Ajax.request({
                url: recordByIdUrl,
                jsonData: Ext.encode({ id: record.get(me.valueField) }), 
                success: function (response, opts) {
                    var res = Ext.decode(response.responseText);
                    if (res.success) {
                        var popupWindow = me.createPopupWindow(xtypeOfView, me, operation);
                        var formView = popupWindow.down('form');
                        var recordToLoad = me.getStore().model.create();
                        Ext.apply(recordToLoad.data, res.result);
                        var entityTypeController = me.picker.getController();
                        entityTypeController.doAfterCreateAction('popup', formView, true, recordToLoad);
                        formView.loadRecord(recordToLoad);
                    } else {
                        abp.message.error(res.error.message, 'Error');
                    }
                },
                failure: function (response, opts) {
                    var res = Ext.decode(response.responseText);
                    Ext.toast(res.exceptionMessage);
                    console.log(response);
                }
            });
        } else if (operation === 'delete') {

            Ext.Msg.show({
                title: app.localize('Confirm'),
                msg: app.localize('ConfirmMessage') + me.nameOfEntity,
                buttons: Ext.Msg.YESNO,
                icon: Ext.Msg.QUESTION,
                fn: function (btn) {
                    if (btn == "yes") {
                        me.deleteEntity(me, record);
                    }
                }
            });

           
        }
        else if (operation === 'create') {
            var popupWindow = me.createPopupWindow(xtypeOfView, me, operation);
            var formView = popupWindow.down('form');
            var entityTypeController = me.picker.getController();
            entityTypeController.doAfterCreateAction('popup', formView, false, null);
        }
    },

    deleteEntity: function (me, record) {
        var me = this,
           picker = me.getPicker();
        if (record.get(me.displayField) == me.getTextValue()) {
            me.setValue('');
        }
        Ext.Ajax.request({
            url: me.store.proxy.api.destroy,
            jsonData: Ext.encode({ id: record.get(me.valueField) }),
            success: function (response, opts) {
                var res = Ext.decode(response.responseText);
                if (res.success) {
                    abp.notify.success('Operation completed successfully.', 'Success');
                    picker.getSelectionModel().deselectAll();
                    me.store.load({ params: me.store.params });
                } else {
                    abp.message.error(res.error.message, 'Error');
                }
            },
            failure: function (response, opts) {
                var res = Ext.decode(response.responseText);
                Ext.toast(res.exceptionMessage);
                console.log(response);
            }
        });
    },

    createPopupWindow: function (xtypeOfView, me, operation) {
        var windowTitle = operation + ' ' + me.nameOfEntity;
        var window = Ext.create('Chaching.view.common.window.ChachingWindowPanel', {
            layout: 'fit',
            title: windowTitle.toUpperCase(),
            autoShow: true,
            modal: true,
            height: '90%',
            width: '90%',
            items: [{
                xtype: xtypeOfView,
                openInPopupWindow: true,
                parentGrid: me.picker,
                showFormTitle: false
            }],
            listeners: {
                beforedestroy: function (cmp, eOpts) {
                },
                destroy : function(cmp, eOpts) {
                    //set record in auto fill combo
                    var record = me.picker.recordToSetInComboBox;
                    if (record)
                    me.onSelect(record);
                }
            }
        });

        return window;
    },



    //onItemClick: function (view, record, node, rowIndex, e) {
    //    if (!view.ownerCt.multiSelect) {

    //        this.selectItem(view, record);
    //        this.collapse();
    //    }
    //},

    //selectItem: function (view, record) {
    //    var me = this;

    //    me._setValue(record);
    //    me.fireEvent('select', me, record);

    //},

    //onSelect: function (view, record) {

    //},

    /**
    * @private
    * Enables the key navs for the BoundList when it is expanded.
    */
    onExpand: function () {
        var me = this;
        var keyNav = this.getPicker().getNavigationModel();
        if (keyNav) {
            keyNav.enable();
        }
        this.doAutoSelect();
        me.focus();
    },

    //onExpand: function () {
    //    var me = this,
    //        picker = me.getPicker(),
    //        store = picker.store,
    //        value = me.value,
    //        selected = [];
    //    debugger;
    //    if (!Ext.isEmpty(value)) {

    //        Ext.Array.each(value.split(','), function (id) {
    //            debugger;
    //            var record = store.findRecord(me.displayField, id);
    //            Ext.Array.push(selected, record);
    //           // Ext.Array.push(selected, store.getById(id));
    //        }, me);
    //    }

    //    picker.getSelectionModel().select(selected);
    //},

    //_setValue: function (record) {
    //    var me = this,
    //    	displays = [],
    //    	values = [];

    //    if (!Ext.isArray(record) && Ext.isObject(record)) {

    //        displays.push(record ? record.get(me.displayField) : '');
    //        values.push(record ? record.get(me.valueField) : '');
    //    } else {

    //        Ext.Array.each(record, function (item) {

    //            Ext.Array.push(displays, (item ? item.get(me.displayField) : ''));
    //            Ext.Array.push(values, (item ? item.get(me.valueField) : ''));
    //        }, me);
    //    }

    //    me.setValue(values);
    //    me.setRawValue(displays);

    //    return me;
    //},
    alignPicker: function () {
        var me = this,
            picker;

        if (me.isExpanded) {
            picker = me.getPicker();
            if (me.matchFieldWidth) {

                picker.setWidth(me.bodyEl.getWidth());
            }
            if (picker.isFloating()) {
                me.doAlign();
            }
        }
    }



});