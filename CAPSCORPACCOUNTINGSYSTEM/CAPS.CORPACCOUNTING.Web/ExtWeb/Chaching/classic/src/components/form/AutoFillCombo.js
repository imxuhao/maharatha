Ext.define('Chaching.components.form.AutoFillCombo', {
    //extend: 'Ext.form.field.Picker',
    extend: 'Ext.form.field.ComboBox',
    xtype: 'autofillcombo',
    requires: ['Ext.grid.Panel'],

    modulePermissions: undefined,
    entityName : null,
    entityType: null,
    entityPermission: null,
    entityGridController : null,
    autoSelect: false,
    selectOnFocus : true,
    enableKeyEvents: true,
    onBindStore: function (store, initial) {
        var me = this,
            picker = me.picker,
            extraKeySpec, valueCollectionConfig;
        // We're being bound, not unbound...
        if (store) {
            // If store was created from a 2 dimensional array with generated field names 'field1' and 'field2'
            if (store.autoCreated) {
                me.queryMode = 'local';
                me.valueField = me.displayField = 'field1';
                if (!store.expanded) {
                    me.displayField = 'field2';
                }
                // displayTpl config will need regenerating with the autogenerated displayField name 'field1'
                if (me.getDisplayTpl().auto) {
                    me.setDisplayTpl(null);
                }
            }
            if (!Ext.isDefined(me.valueField)) {
                me.valueField = me.displayField;
            }
            // Add a byValue index to the store so that we can efficiently look up records by the value field
            // when setValue passes string value(s).
            // The two indices (Ext.util.CollectionKeys) are configured unique: false, so that if duplicate keys
            // are found, they are all returned by the get call.
            // This is so that findByText and findByValue are able to return the *FIRST* matching value. By default,
            // if unique is true, CollectionKey keeps the *last* matching value.
            extraKeySpec = {
                byValue: {
                    rootProperty: 'data',
                    unique: false
                }
            };
            extraKeySpec.byValue.property = me.valueField;
            store.setExtraKeys(extraKeySpec);
            if (me.displayField === me.valueField) {
                store.byText = store.byValue;
            } else {
                extraKeySpec.byText = {
                    rootProperty: 'data',
                    unique: false
                };
                extraKeySpec.byText.property = me.displayField;
                store.setExtraKeys(extraKeySpec);
            }
            // We hold a collection of the values which have been selected, keyed by this field's valueField.
            // This collection also functions as the selected items collection for the BoundList's selection model
            valueCollectionConfig = {
                rootProperty: 'data',
                extraKeys: {
                    byInternalId: {
                        property: 'internalId'
                    },
                    byValue: {
                        property: me.valueField,
                        rootProperty: 'data'
                    }
                },
                // Whenever this collection is changed by anyone, whether by this field adding to it,
                // or the BoundList operating, we must refresh our value.
                listeners: {
                    beginupdate: me.onValueCollectionBeginUpdate,
                    endupdate: me.onValueCollectionEndUpdate,
                    scope: me
                }
            };
            // This becomes our collection of selected records for the Field.
            me.valueCollection = new Ext.util.Collection(valueCollectionConfig);
            // This is the selection model we configure into the dropdown BoundList.
            // We use the selected Collection as our value collection and the basis
            // for rendering the tag list.
            me.pickerSelectionModel = new Ext.selection.RowModel({
                mode: me.multiSelect ? 'SIMPLE' : 'SINGLE',
                // There are situations when a row is selected on mousedown but then the mouse is dragged to another row
                // and released.  In these situations, the event target for the click event won't be the row where the mouse
                // was released but the boundview.  The view will then determine that it should fire a container click, and
                // the DataViewModel will then deselect all prior selections. Setting `deselectOnContainerClick` here will
                // prevent the model from deselecting.
                //deselectOnContainerClick: false,
                //enableInitialSelection: false,
                //pruneRemoved: false,
                //selected: me.valueCollection,
                store: store,
                listeners: {
                    scope: me,
                    lastselectedchanged: me.updateBindSelection
                }
            });
            if (!initial) {
                me.resetToDefault();
            }
            if (picker) {
                me.pickerSelectionModel.on({
                    scope: me,
                    beforeselect: me.onBeforeSelect,
                    beforedeselect: me.onBeforeDeselect
                });
                picker.setSelectionModel(me.pickerSelectionModel);
                if (picker.getStore() !== store) {
                    picker.bindStore(store);
                }
            }
        }
    },
    initComponent: function () {
        var me = this;
        if (me.entityGridController == null) {
            Ext.raise('entityGridController config is required for add/update/delete of an entity for AutoFillCombo(' + me.entityName + ')');
        }
        if (me.entityName == null) {
            Ext.raise('entityName config is required to open edit/create page in popup window for that entity.');
        }
        if (me.entityType == null ) {
            Ext.raise('entityType config is required to open edit/create page  in popup window for that entity.');
        }
        if (me.entityPermission == null) {
            Ext.raise('entityPermission config is required to show or hide action buttons in grid(autocompletecombo).');
        }
        if (me.selectOnFocus && !me.editable) {
            Ext.raise('If selectOnFocus is enabled the combo must be editable: true -- please change one of those settings.');
        }
        //add create icon based upon permission
        if (!me.modulePermissions) {
            me.modulePermissions = {
                read: abp.auth.isGranted('Pages.' + me.entityPermission),
                create: abp.auth.isGranted('Pages.' + me.entityPermission + '.Create'),
                edit: abp.auth.isGranted('Pages.' + me.entityPermission + '.Edit'),
                destroy: abp.auth.isGranted('Pages.' + me.entityPermission + '.Delete')
            };
        }

        //// check permission to create view
        //if (me.modulePermissions.create) {
        //    me.plugins = [{
        //          ptype: 'saki-ficn'
        //        , iconCls: 'fa-plus-square'
        //        , qtip: app.localize('Create')
        //    }];
        //}
        //me.on('iconclick', me.onIconClick, me);

        me.callParent(arguments);
        //key events
        me.on('keyup', me.baseKeyUp, this);
        me.on('specialkey', me.baseSpecialkey, this);
    },
    
    baseKeyUp: function (obj, e, eOpts) {
        obj.handleKeyUp(obj, e, eOpts);
    },

    baseSpecialkey: function (obj, e, eOpts) {
       
        //Merged the code of #5135
        var me = this;
        if (e.getKey() == e.ENTER || e.getKey() == e.TAB || (e.shiftKey && e.getKey() == e.TAB)) {
            me.handleKeyDown(obj, e, eOpts);
        } else if (e.getKey() == e.DOWN) {
            // select the first record on down arrow.
            me.handleKeyUp(obj, e, eOpts);
            if (me.picker && me.isExpanded) {
                e.stopEvent();
                var selectionModel = me.picker.getSelectionModel();
                selectionModel.deselectAll();
                selectionModel.select(0);
                me.picker.getView().focus();
                me.picker.getView().focusRow(0);
            }
        }
    },

    // Custom Action Handlers

    handleKeyUp: function (obj, key, eOpts) {
      
        var me = this;
        if (key && key.isNavKeyPress()) {
            if (key.getKey() == key.DOWN) {
                if (!me.isExpanded) return false;
                var store = me.getStore();
                var count = store.getCount();
                if (count <= 0) return false;
                me.getPicker().toFront();
                return true;
            }

            // Expanding only in case of NavigationKey is pressed. 
            // Disabling the expand in case of SHIFT + TAB, as it was causing other issues.
            if (!me.isExpanded) {
                me.expand();
            }

            if (me.isExpanded) me.getPicker().toFront();
        }

        if (key && (key.getKey() == key.ESC || key.getKey() == key.ENTER || key.getKey() == key.TAB)) {
            obj.collapse();
            return true;
        }

        return true;
    },


    handleKeyDown: function (obj, key, eOpts) {
        var me = this;
        if (key && (key.getKey() == key.ENTER || key.getKey() == key.TAB)) {
            var picker = me.getPicker();
            if (picker) {
                picker.suspendEvents(true);
                this.handlePickerEvent('btnSelect');
                picker.resumeEvents();
            }
            return false;
        }
        return true;
    },
    getValue: function () {
        var me = this;
        return me.hiddenValue;
    },

    getTextValue: function () {
        var me = this;
        return me.value;
    },
    onSelect: function (record) {
        if (!this.preventSelectOnClick) {
            var me = this;
            var idVal = record.data[me.valueField];
            var nameVal = record.data[me.displayField];
            me.setValue(nameVal);
            me.hiddenValue = idVal;
            me.fireEvent('change', me, idVal, record);
            me.collapse();
            //me.focus();
            me.fireEvent('select', me, record);
        }
    },
    handlePickerEvent: function (event, rec) {
        var me = this,
            picker = me.getPicker(),
            view = picker.getView(),
            model = view.getSelectionModel(),
            record = model.getLastSelected(),
            parentWindow = me.up('window');
        // Added for #3103 - Default Values on PR Import Form
        if (!record && rec) record = rec;

        if (!record && view.store.getCount() == 1) {
            // get it from view 
            record = view.store.getAt(0);
        }

        switch (event) {
            // Added two diffirent events to resolve issue of key events & mouse events.
            case 'btnSelectClicked':
                if (record) {
                    me.onSelect(record);
                    model.deselectAll();
                    model.lastSelected = undefined;
                    // clear last filter used and last query
                    me.lastQuery = '';
                    me.getStore().clearFilter();
                }
                break;
            case 'btnSelect':
                if (me.getRawValue()) {
                    if (record) {
                        me.onSelect(record);
                    } else {
                        if (me.value && me.hiddenValue) {
                            var r = undefined;
                            r = me.getStore().findRecord(me.displayField, me.rawValue);
                            if (r) {
                                me.hiddenValue = r.get(me.valueField);
                            } else {
                                me.setValue('');
                            }
                        } else {
                            me.setValue('');
                        }
                        me.focus();
                    }
                } else {
                    me.hiddenValue = '';
                    me.setValue('');
                    me.collapse();
                    me.focus();
                }
                // clear last filter used and last query
                model.lastSelected = undefined;
                me.lastQuery = '';
                me.getStore().clearFilter();
                model.deselectAll();
                break;
            //case 'btnNew':
            //    //try to disable parent window's formpanel once child window is oepned see #1522
            //    //once child window is opened then the controls taborder of child windows coflict with parent windows controls.
            //    me.setDisabled(true);
            //    if (parentWindow) {
            //        parentWindow.down('form').setDisabled(true);
            //    }
            //    var wndEdit = this.getEditWnd(me.opts);
            //    //wndEdit.opts = this.opts;
            //    //add destroy event handler for child window to enable parent again
            //    wndEdit.on("destroy", me.enableParent, this);
            //    wndEdit.parent = parentWindow;
            //    wndEdit.requestor = me;
            //    wndEdit.show();
            //    wndEdit.bindParent(me); //grid.pickerObj
            //    var emptyRec = {
            //        AllowDelete: false
            //    };
            //    wndEdit.getController().setDetails(emptyRec);
            //    if (parentWindow == null && me.up('grid').id != null) {
            //        var formId = me.up('grid').id;
            //        var isDefault = this.store.findRecord('IsDefault', true);
            //        var records = [];
            //        if (isDefault) {
            //            records['IsDefault'] = isDefault.data.IsDefault;
            //            records['IsFirstRec'] = false;
            //        } else {
            //            records['IsDefault'] = true;
            //            records['IsFirstRec'] = true;
            //        }
            //        records['FormName'] = formId;
            //        me.setDisabled(false);
            //        if (wndEdit.setDefaultValues) {
            //            wndEdit.setDefaultValues(records);
            //        }
            //    } else {
            //        if (wndEdit.setDefaultValues) {
            //            wndEdit.setDefaultValues();
            //        }
            //    }
            //    break;
            //case 'btnEdit':
            //    if (record == null) {
            //        Ext.Msg.show({
            //            title: Aliaces.FormValidationFailure,
            //            msg: 'Please select record to edit',
            //            buttons: Ext.Msg.OK,
            //            icon: Ext.Msg.ERROR
            //        });
            //        return;
            //    }
            //    //try to disable parent window's formpanel once child window is oepned
            //    //once child window is opened then the controls taborder of child windows coflict with parent windows controls.
            //    me.setDisabled(true);
            //    if (parentWindow) {
            //        parentWindow.down('form').setDisabled(true);
            //    }
            //    var wndEdit = this.getEditWnd(me.opts);
            //    //add destroy event handler for child window to enable parent again
            //    wndEdit.on("destroy", me.enableParent, this);
            //    wndEdit.parent = parentWindow;
            //    wndEdit.requestor = me;
            //    if (me.loadOnEdit) {
            //        // If not retrieving all information... then retrieve 
            //        var store = Ext.create('NextGen.store.' + me.originalWndClass + '.' + me.originalWndClass + 'Store');
            //        store.proxy.url = global_url + me.originalWndClass + '/GetDetailsById';
            //        if (wndEdit.isTransactionWindow)//for transaction windows always primary key is accounttransactionid
            //            store.proxy.extraParams.pkId = record.get('AccountTransactionId');
            //        else
            //            store.proxy.extraParams.pkId = record.get(me.valueField);
            //        store.load(function (records, operation, success) {
            //            wndEdit.show();
            //            wndEdit.bindParent(me);
            //            wndEdit.getController().setDetails(records[0].data);
            //        });
            //    } else {
            //        // IF retrieving all information.
            //        wndEdit.show();
            //        wndEdit.bindParent(me);
            //        wndEdit.getController().setDetails(record.data);
            //    }

            //    break;
            //case 'btnDelete':
            //    Ext.Msg.show({
            //        title: NextGen.locale.messages.DeleteConfirmationTitle,
            //        msg: NextGen.locale.messages.DeleteConfirmation,
            //        buttons: Ext.Msg.YESNO,
            //        icon: Ext.Msg.QUESTION,
            //        //animateTarget: records[0].id,
            //        fn: function (btn) {
            //            switch (btn) {
            //                case "yes":
            //                    me.doDeleteCurent(record);
            //                    break;
            //                case "no":
            //                    break;
            //            }
            //        }
            //    });
            //    break;
            case 'btnRefresh':
                me.getPicker().getSelectionModel().deselectAll();
                picker.down('button[itemId=btnDropDownEdit]').disable();
                picker.down('button[itemId=btnDropDownDelete]').disable();
                picker.down('button[itemId=btnDropDownSelect]').disable();
                me.store.load({ params: me.store.params });
                break;
        }
    },






    //onIconClick: function () {
    //    var me = this;
    //    var entityType = me.entityType;
    //    me.createWindow(entityType, 'create', null);
    //},
    /**
     * Creates and returns the tree panel to be used as this field's picker.
     */
    createPicker: function () {
        var me = this,
            dockedItems = [{
                 anchor: '100%',
                 dock: 'bottom',
                 ui: 'plainBottom',
                 frame: false,
                 xtype: 'toolbar',
                 items: ['->', {
                     xtype: 'button',
                     text: 'Add',
                     iconAlign: 'left',
                     scale: 'small',
                     iconCls: 'fa fa-plus-square',
                     ui: 'actionButton',
                     handler: function (btn) {
                         var entityType = me.entityType;
                         me.createWindow(entityType, 'create', null);
                     }
                 }]
             }],
            columnList = me.createGridColumns();
	        opts = Ext.apply({
	            shrinkWrapDock: 2,
	            manageHeight: true,
	            store: me.store,
	            displayField: me.displayField,
	            columns: columnList,
	            columnLines: false,
	            rowLines: false,
	            forceFit: true,
	            layout: 'fit',
	            floating: true,
	            dockedItems: me.modulePermissions.create ? dockedItems : null,
	            multiSelect: false,
	            cls: 'chaching-transactiongrid',
	            controller: me.entityGridController,
	            selModel: {
	                selType: 'rowmodel', // rowmodel is the default selection model
	            },
	            viewConfig: {
	                stripeRows: true,
	            }
                //,
	            //listeners: {
	            //    scope: me,
	            //    itemclick: me.onItemClick,
	            //}
	        }, me.listConfig);
	       
        var picker = me.picker = Ext.create('Ext.grid.Panel', opts);

        picker.on({
           // select: me.onPickerSelect,
            blur: me.onPickerBlur,
            celldblclick: me.onPickerCellDblClick,
            //selectionchange: me.onPickerSelectionChange,
            refresh: me.onListRefresh,
            scope: me
        });


        picker.getView().on('itemkeydown', me.onViewItemKeyDown);

        // hack: pass getNode() to the view
        picker.getNode = function () {
            picker.getView().getNode(arguments);
        };

        //picker.getSelectionModel().on({
        //    beforeselect: me.onBeforeSelect,
        //    beforedeselect: me.onBeforeDeselect,
        //    scope: me
        //});

        //To findout Mac System and Only for Mozilla.
        if (Ext.isGecko && Ext.isMac) {
            me.keyMap = new Ext.util.KeyMap({
                target: me.inputEl,
                key: [40, 38],
                fn: me.baseSpecialkey,
                scope: me
            });
        }
        return picker;
    },

   

    // Picker Events
    onPickerNew: function () {
        this.handlePickerEvent('btnNew');
    },

    onPickerEdit: function () {
        this.handlePickerEvent('btnEdit');
    },

    onPickerDelete: function () {
        this.handlePickerEvent('btnDelete');
    },

    onPickerRefresh: function () {
        this.handlePickerEvent('btnRefresh');
    },

    onPickerSelected: function () {
        this.handlePickerEvent('btnSelectClicked');
    },

    onPickerSelect: function () {
        return false; // do nothing
    },

    onPickerBlur: function () {
        this.handlePickerEvent('btnSelectClicked');
    },

    onPickerCellDblClick: function (field, td, cellIndex, record, tr, rowIndex, e, eOpts) {
        // fire select  
        var me = this;
        if (!me.preventSelectOnDblClick) {
            this.handlePickerEvent('btnSelectClicked');
        }
    },

    onPickerSelectionChange: function () {
        var me = this,
            picker = me.getPicker();

        if (!me.disableEditBtnOnSelection)
            picker.down('button[itemId=btnDropDownEdit]').enable();

        if (!me.disableDeleteBtnOnSelection)
            picker.down('button[itemId=btnDropDownDelete]').enable();

        picker.down('button[itemId=btnDropDownSelect]').enable();

        return false;
    },

    onListRefresh: function () {
        this.alignPicker();
        this.syncSelection();
    },
    onViewItemKeyDown: function (view, record, item, index, e) {
      
        if (e.getKey() == e.ENTER || e.getKey() == e.TAB) {
            // fire select 
            var me = this;
            if (typeof (me.handlePickerEvent) === 'function')
                me.handlePickerEvent('btnSelectClicked');
            else {
                me = this.up('autofillcombo');
                me.handlePickerEvent('btnSelectClicked');
            }
        }
    },
    setValue: function (v) {
        var me = this;
        if (!me.preventClearOnBlur || v != "") {
            if (me.preventClearOnBlur) {
                if (this.rawValue != v && this.rawValue != "") {
                    v = this.rawValue;
                }
            }
            if (v === undefined) {
                me.value = "";
                me.setRawValue("");
                return "";
            }

            if (v == null || v == 0 || v == "") {
                me.value = "";
                me.setRawValue("");
                me.hiddenValue = null;
            }
            if (typeof (v) === "string") {
                v = Ext.util.Format.htmlDecode(v);
            }
            me.value = v;
            me.setRawValue(v);
            me.checkChange();
            if (me.inputEl) {
                me.inputEl.removeCls(me.emptyCls);
            }
        }
        return me;
    },


    doQuery: function (queryString, forceAll, rawQuery) {
        var me = this,
            store = me.getStore(),
            filters = store.getFilters(),
            // if we have a queryString and the queryFilter is not filtering the store, we should do a localQuery
            refreshFilters = !!queryString && me.queryFilter && (filters.indexOf(me.queryFilter) < 0),
            // Decide if, and how we are going to query the store
            queryPlan = me.beforeQuery({
                lastQuery: me.lastQuery || '',
                query: queryString || '',
                rawQuery: rawQuery,
                forceAll: forceAll,
                combo: me,
                cancel: false
            });
        // Allow veto.
        if (queryPlan !== false && !queryPlan.cancel) {
            // If they're using the same value as last time (and not being asked to query all), 
            // and the filters don't need to be refreshed, just show the dropdown
            if (me.queryCaching && !refreshFilters && queryPlan.query === me.lastQuery) {
                // The filter changing was done with events suppressed, so
                // refresh the picker DOM while hidden and it will layout on show.
                me.getPicker().getView().refresh();
                me.expand();
                me.afterQuery(queryPlan);
            } else // Otherwise filter or load the store
            {
                me.lastQuery = queryPlan.query;
                if (me.queryMode === 'local') {
                    me.doLocalQuery(queryPlan);
                } else {
                    me.doRemoteQuery(queryPlan);
                }
            }
            return true;
        } else // If the query was vetoed we still need to check the change
            // in case custom validators are used
        {
            me.startCheckChangeTask();
        }
        return false;
    },

    createGridColumns: function () {
        var me = this,
            //store = Ext.create('Chaching.store.' + me.store),
             store = me.store,
           // model = me.store.model.create(),
            fileds = store.model.fields.items,
            count = fileds.length,
            columns = [];
        for (var i = 0; i < count; i++) {
            if (fileds[i].hidden == false) {
                var column = {
                    text: fileds[i].headerText == null ? fileds[i].name : fileds[i].headerText,
                    sortable: false,
                    hideable: false,
                    menuDisabled: true,
                    filterable: true,
                    minWidth : 50,
                    width: fileds[i].width,
                    hidden: fileds[i].hidden,
                    dataIndex: fileds[i].name,
                    flex: fileds[i].width > 0 ? null : fileds[i].flex
                }
                columns.push(column);
            }
        }
      
        var actionColumn = {};
        var actionColumnItems = [];
        var editActionItem = {
            scale: 'small',
            iconCls: 'editCls',
          //  ui: 'actionButton',
            tooltip: app.localize('Edit'),
            handler : function(grid, rowIndex, colIndex) {
                var entityType = me.entityType;
                var rec = grid.getStore().getAt(rowIndex);
                me.createWindow(entityType, 'edit', rec);
               
            }
        };
        var deleteActionItem = {
            scale: 'small',
            iconCls: 'deleteCls',
           // ui: 'actionButton',
            tooltip: app.localize('Delete'),
            handler: function (grid, rowIndex, colIndex) {
                var entityType = me.entityType;
                var rec = grid.getStore().getAt(rowIndex);
                me.createWindow(entityType, 'delete', rec);
            }
        };
        if (me.modulePermissions.edit) {
           // actionColumnItems.push(editActionItem);

            var editActionColumn = {
                xtype: 'actioncolumn',
                width: '5%',
                minWidth: 15,
                sortable: false,
                hideable: false,
                menuDisabled: true,
                filterable: true,
                items: [editActionItem]//actionColumnItems
            }
            columns.push(editActionColumn);
        }

        if (me.modulePermissions.destroy) {
            //actionColumnItems.push(deleteActionItem);
            var deleteActionColumn = {
                xtype: 'actioncolumn',
                width: '5%',
                minWidth: 15,
                sortable: false,
                hideable: false,
                menuDisabled: true,
                filterable: true,
                items: [deleteActionItem]//actionColumnItems
            }
            columns.push(deleteActionColumn);
        }

        //if (actionColumnItems.length > 0) {
        //    actionColumn = {
        //        xtype: 'actioncolumn',
        //        width: '8%',
        //        minWidth: 30,
        //        sortable: false,
        //        hideable: false,
        //        menuDisabled: true,
        //        filterable: true,
        //        items: actionColumnItems
        //    }
        //    columns.push(actionColumn);
        //} 
       return columns;
    },
    createWindow: function (xtype, operation, record) {
        var me = this,
            picker = me.picker;
        if (!picker) me.picker = me.getPicker();
        var xtypeOfView = "";
        if (operation === 'create') {
            xtypeOfView = xtype + ".create";
        } else if (operation === 'edit') {
            xtypeOfView = xtype + ".edit";
        }

        if (me.store && me.store.proxy && (me.store.proxy.urlToGetRecordById == "" || me.store.proxy.urlToGetRecordById == undefined)) {
            Ext.raise('urlToGetRecordById config is required in proxy config of ' + me.store.$className + ' to edit record in AutoFillCombo(' + me.entityName+')');
        }
        var recordByIdUrl = me.store.proxy.urlToGetRecordById;
        if (operation === 'edit') {
            Ext.Ajax.request({
                url: recordByIdUrl,
                jsonData: Ext.encode({ id: 2 }),  //record.get(me.valueField)
                success: function (response, opts) {
                    var res = Ext.decode(response.responseText);
                    if (res.success) {
                        var popupWindow = me.createPopupWindow(xtypeOfView, me, operation);
                        var formView = popupWindow.down('form');
                        var recordToLoad = me.getStore().model.create();
                        Ext.apply(recordToLoad.data, res.result);
                        var entityTypeController = me.picker.getController();
                        entityTypeController.doAfterCreateAction('popup', formView, true, recordToLoad);
                        formView.loadRecord(recordToLoad);
                    } else {
                        abp.message.error(res.error.message, 'Error');
                    }
                },
                failure: function (response, opts) {
                    var res = Ext.decode(response.responseText);
                    Ext.toast(res.exceptionMessage);
                    console.log(response);
                }
            });
        } else if (operation === 'delete') {
            Ext.Ajax.request({
                url: me.store.proxy.api.destroy,
                jsonData: Ext.encode({ id: 2 }),
                success: function (response, opts) {
                    var res = Ext.decode(response.responseText);
                    if (res.success) {
                        abp.notify.success('Operation completed successfully.', 'Success');
                    } else {
                        abp.message.error(res.error.message, 'Error');
                    }
                },
                failure: function (response, opts) {
                    var res = Ext.decode(response.responseText);
                    Ext.toast(res.exceptionMessage);
                    console.log(response);
                }
            });
        }
        else if (operation === 'create') {
            var popupWindow = me.createPopupWindow(xtypeOfView, me, operation);
            var formView = popupWindow.down('form');
            var entityTypeController = me.picker.getController();
            entityTypeController.doAfterCreateAction('popup', formView, false, null);
        }
    },

    createPopupWindow: function (xtypeOfView, me, operation) {
        var windowTitle = operation + ' ' + me.entityName;
        var window = Ext.create('Chaching.view.common.window.ChachingWindowPanel', {
            layout: 'fit',
            title: windowTitle.toUpperCase(),
            autoShow: true,
            modal: true,
            height: '90%',
            width: '90%',
            items: [{
                xtype: xtypeOfView,
                openInPopupWindow: true,
                parentGrid: me.picker,
                showFormTitle: false
            }]
        });

        return window;
    },



    //onItemClick: function (view, record, node, rowIndex, e) {
    //    if (!view.ownerCt.multiSelect) {

    //        this.selectItem(view, record);
    //        this.collapse();
    //    }
    //},

    //selectItem: function (view, record) {
    //    var me = this;

    //    me._setValue(record);
    //    me.fireEvent('select', me, record);

    //},

    //onSelect: function (view, record) {

    //},

    /**
    * @private
    * Enables the key navs for the BoundList when it is expanded.
    */
    onExpand: function () {
        var me = this;
        var keyNav = this.getPicker().getNavigationModel();
        if (keyNav) {
            keyNav.enable();
        }
        this.doAutoSelect();
        me.focus();
    },

    //onExpand: function () {
    //    var me = this,
    //        picker = me.getPicker(),
    //        store = picker.store,
    //        value = me.value,
    //        selected = [];
    //    debugger;
    //    if (!Ext.isEmpty(value)) {

    //        Ext.Array.each(value.split(','), function (id) {
    //            debugger;
    //            var record = store.findRecord(me.displayField, id);
    //            Ext.Array.push(selected, record);
    //           // Ext.Array.push(selected, store.getById(id));
    //        }, me);
    //    }

    //    picker.getSelectionModel().select(selected);
    //},

    //_setValue: function (record) {
    //    var me = this,
    //    	displays = [],
    //    	values = [];

    //    if (!Ext.isArray(record) && Ext.isObject(record)) {

    //        displays.push(record ? record.get(me.displayField) : '');
    //        values.push(record ? record.get(me.valueField) : '');
    //    } else {

    //        Ext.Array.each(record, function (item) {

    //            Ext.Array.push(displays, (item ? item.get(me.displayField) : ''));
    //            Ext.Array.push(values, (item ? item.get(me.valueField) : ''));
    //        }, me);
    //    }

    //    me.setValue(values);
    //    me.setRawValue(displays);

    //    return me;
    //},
    alignPicker: function () {
        var me = this,
            picker;

        if (me.isExpanded) {
            picker = me.getPicker();
            if (me.matchFieldWidth) {

                picker.setWidth(me.bodyEl.getWidth());
            }
            if (picker.isFloating()) {
                me.doAlign();
            }
        }
    }



});